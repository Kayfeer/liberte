Rôle : Tu es Lead Architect spécialisé en cryptographie, réseaux P2P et Rust.

Projet : "Liberté" - Une alternative à Discord souveraine, sécurisée et hybride. Cible : Windows (x64, ARM64), Linux (x64).

Architecture Fondamentale :

Topology : P2P par défaut (Mesh).

Mode Premium (0.99€/mois) : Accès à un "Nœud Relais" (VPS) pour :

Persistance des images/fichiers (Stockage chiffré).

Relais Audio/Vidéo haute performance (SFU).

Sécurité : Chiffrement E2EE (XChaCha20-Poly1305 + Noise Protocol). Aucune métadonnée en clair sur le serveur.

Instructions Techniques Détaillées :

1. Cœur Système & Réseau (Rust Crate: liberte_core)
Stack Réseau : Utilise libp2p avec quinn (QUIC) comme transport principal.

DNS & Censure : Intègre hickory-dns (anciennement trust-dns). Force la résolution DNS via DoH (DNS over HTTPS) sur 1.1.1.1 (Cloudflare) ou 8.8.8.8 (Google) directement dans le code pour ignorer les DNS du système d'exploitation/FAI.

Identité : Génération de clés Ed25519 locales. L'ID utilisateur est la clé publique. Aucun email, aucun numéro.

2. Audio/Vidéo (Le défi SFU)
Utilise WebRTC via webrtc-rs.

Mode P2P (Gratuit) : Mesh direct (Full Mesh). Chaque client envoie son flux à tous les autres.

Mode SFU (Premium) : Le serveur VPS agit comme une Selective Forwarding Unit (SFU).

Contrainte Critique : Le SFU ne doit JAMAIS déchiffrer les flux média. Implémente le MLS (Message Layer Security) ou l'Insertable Streams pour que le serveur route les paquets RTP chiffrés sans avoir les clés de session.

3. Gestion des Données & Images
Stockage : Base de données locale SQLite (chiffrée via SQLCipher).

Images (Gratuit) : Transfert direct P2P. Si l'émetteur se déconnecte, l'image est inaccessible pour ceux qui ne l'ont pas encore chargée.

Images (Premium) : Upload vers le VPS. Le serveur reçoit un blob binaire chiffré. Il ne sait pas si c'est une image ou du texte.

Sécurité CSAM (Zéro Backdoor) : Implémente un hachage perceptuel côté client (ex: pHash). Avant l'envoi chiffré, le client vérifie le hash contre une liste noire locale compacte (Bloom Filter) de signatures connues de contenu illégal. Si match = refus d'envoi.

4. Paiement & Premium
Prévois une interface dans le backend Rust pour vérifier un statut "Premium" via une signature cryptographique (Token signé par le serveur de paiement).

Le paiement se fera en crypto (Monero/BTC). Le code doit juste exposer une API fn check_premium_status(pubkey) -> bool.

5. Frontend (Tauri + React)
UI sombre, minimaliste, type "Discord".

Pas de télémétrie. Pas d'analytics.

Indicateur visuel clair : "Connexion directe" (P2P) ou "Relayée/Sécurisée" (SFU).

6. Livraison & Build
Crée un fichier Cargo.toml workspace avec les membres : liberte-client (Tauri), liberte-server (Le relais VPS), liberte-shared.

Configure les Github Actions pour compiler automatiquement :

windows-x86_64, windows-aarch64 (ARM).

linux-x86_64 (AppImage).

Le serveur doit être déployable via un simple docker-compose up.

Livre-moi l'arborescence des fichiers, le code Rust critique (Réseau + Crypto) et la configuration Tauri.

Ce que tu dois savoir sur la réalisation
Avec ce prompt, Claude Code va générer une base très solide, mais voici les points de friction que tu devras gérer toi-même ensuite :

La liste noire (CSAM) : Le code va prévoir un filtre ("Bloom Filter"), mais cette liste doit être mise à jour. Tu devras trouver un moyen de diffuser les mises à jour de cette liste de hashs aux clients sans qu'ils sachent ce qu'il y a dedans (c'est le principe du Bloom Filter, on sait si ça existe, mais on ne peut pas reconstruire l'image).

Windows ARM64 : C'est encore un peu "nouveau" pour certaines dépendances Rust (notamment WebRTC). Il est possible que la compilation demande quelques ajustements manuels sur les librairies C++ sous-jacentes.

Paiement Crypto : Le prompt demande une fonction check_premium_status. Tu devras connecter ça à un petit script python ou nodejs sur ton serveur qui surveille ton wallet crypto et qui dit au serveur Rust "Ok, cette clé publique a payé, active-lui le mode SFU".

----

Rôle : Tu es Lead Architect spécialisé en cryptographie, réseaux P2P et Rust.

Projet : "Liberté" - Une alternative à Discord souveraine, sécurisée et hybride. Cible : Windows (x64, ARM64), Linux (x64).

Architecture Fondamentale :

Topology : P2P par défaut (Mesh).

Mode Premium (0.99€/mois) : Accès à un "Nœud Relais" (VPS) pour :

Persistance des images/fichiers (Stockage chiffré).

Relais Audio/Vidéo haute performance (SFU).

Sécurité : Chiffrement E2EE (XChaCha20-Poly1305 + Noise Protocol). Aucune métadonnée en clair sur le serveur.

Instructions Techniques Détaillées :

1. Cœur Système & Réseau (Rust Crate: liberte_core)
Stack Réseau : Utilise libp2p avec quinn (QUIC) comme transport principal.

DNS & Censure : Intègre hickory-dns (anciennement trust-dns). Force la résolution DNS via DoH (DNS over HTTPS) sur 1.1.1.1 (Cloudflare) ou 8.8.8.8 (Google) directement dans le code pour ignorer les DNS du système d'exploitation/FAI.

Identité : Génération de clés Ed25519 locales. L'ID utilisateur est la clé publique. Aucun email, aucun numéro.

2. Audio/Vidéo (Le défi SFU)
Utilise WebRTC via webrtc-rs.

Mode P2P (Gratuit) : Mesh direct (Full Mesh). Chaque client envoie son flux à tous les autres.

Mode SFU (Premium) : Le serveur VPS agit comme une Selective Forwarding Unit (SFU).

Contrainte Critique : Le SFU ne doit JAMAIS déchiffrer les flux média. Implémente le MLS (Message Layer Security) ou l'Insertable Streams pour que le serveur route les paquets RTP chiffrés sans avoir les clés de session.

3. Gestion des Données & Images
Stockage : Base de données locale SQLite (chiffrée via SQLCipher).

Images (Gratuit) : Transfert direct P2P. Si l'émetteur se déconnecte, l'image est inaccessible pour ceux qui ne l'ont pas encore chargée.

Images (Premium) : Upload vers le VPS. Le serveur reçoit un blob binaire chiffré. Il ne sait pas si c'est une image ou du texte.

Sécurité CSAM (Zéro Backdoor) : Implémente un hachage perceptuel côté client (ex: pHash). Avant l'envoi chiffré, le client vérifie le hash contre une liste noire locale compacte (Bloom Filter) de signatures connues de contenu illégal. Si match = refus d'envoi.

4. Paiement & Premium
Prévois une interface dans le backend Rust pour vérifier un statut "Premium" via une signature cryptographique (Token signé par le serveur de paiement).

Le paiement se fera en crypto (Monero/BTC). Le code doit juste exposer une API fn check_premium_status(pubkey) -> bool.

5. Frontend (Tauri + React)
UI sombre, minimaliste, type "Discord".

Pas de télémétrie. Pas d'analytics.

Indicateur visuel clair : "Connexion directe" (P2P) ou "Relayée/Sécurisée" (SFU).

6. Livraison & Build
Crée un fichier Cargo.toml workspace avec les membres : liberte-client (Tauri), liberte-server (Le relais VPS), liberte-shared.

Configure les Github Actions pour compiler automatiquement :

windows-x86_64, windows-aarch64 (ARM).

linux-x86_64 (AppImage).

Le serveur doit être déployable via un simple docker-compose up.

Livre-moi l'arborescence des fichiers, le code Rust critique (Réseau + Crypto) et la configuration Tauri.

Ce que tu dois savoir sur la réalisation
Avec ce prompt, Claude Code va générer une base très solide, mais voici les points de friction que tu devras gérer toi-même ensuite :

La liste noire (CSAM) : Le code va prévoir un filtre ("Bloom Filter"), mais cette liste doit être mise à jour. Tu devras trouver un moyen de diffuser les mises à jour de cette liste de hashs aux clients sans qu'ils sachent ce qu'il y a dedans (c'est le principe du Bloom Filter, on sait si ça existe, mais on ne peut pas reconstruire l'image).

Windows ARM64 : C'est encore un peu "nouveau" pour certaines dépendances Rust (notamment WebRTC). Il est possible que la compilation demande quelques ajustements manuels sur les librairies C++ sous-jacentes.

Paiement Crypto : Le prompt demande une fonction check_premium_status. Tu devras connecter ça à un petit script python ou nodejs sur ton serveur qui surveille ton wallet crypto et qui dit au serveur Rust "Ok, cette clé publique a payé, active-lui le mode SFU".